
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HTTPS - 星延</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="HTTPS为什么要有https？
因为 http 不安全
如何定义“安全”？
如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。
什么是HTTPS,"> 
    <meta name="author" content="chenyu"> 
    <link rel="alternative" href="atom.xml" title="星延" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">星延</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://mschenyu.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">HTTPS</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">HTTPS</h1>
        <div class="stuff">
            <span>八月 29, 2020</span>
            

        </div>
        <div class="content markdown">
            <h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><strong>为什么要有https？</strong></p>
<p>因为 http 不安全</p>
<p>如何定义“安全”？</p>
<p>如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。</p>
<p><strong>什么是HTTPS</strong></p>
<p>HTTPS = HTTP + SSL/TLS；https让http运行在了安全的SSL/TLS协议上，收发报文不再使用 Socket API，而是调用专门的安全接口。</p>
<p>![image-20200824222951264](/Users/chenyu/Library/Application Support/typora-user-images/image-20200824222951264.png)</p>
<ul>
<li><p>SSL：安全套接层，在 OSI 模型中处于第 5 层（会话层）</p>
</li>
<li><p>TLS：1999年，SSL被改名为TLS（传输层安全），正式标准化，所以 TLS1.0 实际上就是 SSLv3.1，目前应用的最广泛的 TLS 是 1.2。</p>
<p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。</p>
</li>
</ul>
<p>TLS 的密码套件命名：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</p>
<p>如：ECDHE-RSA-AES256-GCM-SHA38</p>
<p>含义：握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数</p>
<p><strong>OpenSSL</strong></p>
<p>说到 TLS，就不能不谈到 OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，是 SSL/TLS 的具体实现。</p>
<p><em>HTTPS是怎么实现机密性、完整性，身份认证和不可否认特性的呢？</em></p>
<h2 id="机密性"><a href="#机密性" class="headerlink" title="机密性"></a>机密性</h2><p>为什么要有机密性？</p>
<p>因为http是明文传输的，明文的意思就是头部字段等信息直接使用ASCII码这种人能看懂的符号传递，很容易被劫取和篡改。当我们使用http进行金钱方面的交易时，是毫无安全性可言的。</p>
<p>实现机密性最常用的手段是“加密”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。</p>
<p>这里的“钥匙”就叫做“密钥”（key），加密前的消息叫“明文”（plain text/cleartext），加密后的乱码叫“密文”（cipher text），使用密钥还原明文的过程叫“解密”（decrypt），是加密的反操作，加密解密的操作过程就是“加密算法”。</p>
<p>按照密钥的使用方式，加密可以分为两大类：对称加密和非对称加密。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密：加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<p>举个例子，你想要登录某网站，只要事先和它约定好使用一个对称密码，通信过程中传输的全是用密钥加密后的密文，只有你和网站才能解密。黑客即使能够窃听，看到的也只是乱码，因为没有密钥无法解出明文，所以就实现了机密性。</p>
<p> 目前最常用的加密算法是 AES（高级加密标准），密钥长度可以是128、192 或 256。</p>
<p>对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文），常用的是 GCM、CCM 和Poly1305。</p>
<p>把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。比如，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM；ChaCha20-Poly1305 意思是ChaCha20 算法，使用的分组模式是 Poly1305。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>对称加密有一个缺点，就是无法解决“密钥交换”问题，因为在对称加密算法中只要持有密钥就可以解密。如果你和网站约定的密钥在传递途中被黑客窃取，那他就可以在之后随意解密收发的数据，通信过程也就没有机密性可言了。</p>
<p>所以，就出现了非对称加密，也叫公钥加密算法。它有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</p>
<p>公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。</p>
<img src="/Users/chenyu/Library/Application Support/typora-user-images/image-20200826102824728.png" alt="image-20200826102824728" style="zoom: 33%;" />

<p>RSA是最著名的非对称加密算法，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。</p>
<p>ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</p>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>非对称加密虽然没有“密钥交换”问题，但因为它们都是基于复杂的数学难题，运算速度很慢，比对称加密算法差了好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</p>
<p>所以，TLS里使用了”混合加密“方式：</p>
<ul>
<li>在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题；【用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。】</li>
<li>后续全都使用对称加密进行通信。</li>
</ul>
<h2 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h2><p>为什么要有完整性？</p>
<p>因为黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。如果没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。</p>
<p>实现完整性的手段主要是 摘要算法，也就是常说的散列函数、哈希函数。</p>
<p>你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。</p>
<p>你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（SecureHash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。</p>
<p>目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2，SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要</p>
<p><strong>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。</strong></p>
<p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。如果黑客在中间哪怕改动了一个标点符号，摘要也会完全不同，网站计算比对就会发现消息被窜改，是不可信的。</p>
<p>![image-20200826105420184](/Users/chenyu/Library/Application Support/typora-user-images/image-20200826105420184.png)</p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>为什么要有身份认证？</p>
<p>因为黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。所以，客户端需要确认服务器身份。</p>
<h2 id="TLS连接过程解析"><a href="#TLS连接过程解析" class="headerlink" title="TLS连接过程解析"></a>TLS连接过程解析</h2><p>当你在浏览器地址栏里键入“https”开头的 URI，再按下回车，会发生什么呢？</p>
<p>浏览器首先要从 URI 里提取出协议名和域名。因为协议名是“https”，所以浏览器就知道了端口号是默认的 443，它再用 DNS 解析域名，得到目标的 IP 地址，然后就可以使用三次握手与网站建立 TCP 连接了。</p>
<p>在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。但现在是 HTTPS 协议，<strong>它需要再用另外一个“握手”过程，在 TCP 上建立安全连接</strong>，之后才是收发 HTTP 报文</p>
<p>开局一张图：</p>
<img src="/Users/chenyu/Library/Application Support/typora-user-images/image-20200827111003908.png" alt="image-20200827111003908" style="zoom:50%;" />

<p>TLS握手过程：</p>
<p><strong>1.客户端发出请求（ClientHello）</strong></p>
<ul>
<li>支持的协议版本，比如TLS 1.0版</li>
<li>一个客户端生成的随机数，稍后用于生成”对话密钥”</li>
<li>支持的密码套件（支持的加密方法）</li>
</ul>
<p>​    <img src="/Users/chenyu/Library/Application Support/typora-user-images/image-20200827102623833.png" alt="image-20200827102623833" style="zoom:50%;" /></p>
<p><strong>2.服务器回应（ServerHello）</strong></p>
<ul>
<li><p>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p>
</li>
<li><p>一个服务器生成的随机数，稍后用于生成”对话密钥”</p>
</li>
<li><p>确认使用的加密方法，比如RSA公钥加密</p>
</li>
<li><p>服务器证书</p>
<img src="/Users/chenyu/Library/Application Support/typora-user-images/image-20200827103003869.png" alt="image-20200827103003869" style="zoom:50%;" />

</li>
</ul>
<p>接下来是一个关键的操作，因为服务器选择了 ECDHE 算法，所以它会在证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证。</p>
<img src="/Users/chenyu/Library/Application Support/typora-user-images/image-20200827103447339.png" alt="image-20200827103447339" style="zoom:50%;" />

<p>之后是“Server Hello Done”消息，服务器说：“我的信息就是这些，打招呼完毕。”</p>
<p>这样第一个消息往返就结束了（两个 TCP 包），结果是客户端和服务器通过明文共享了三个信息：Client Random、Server Random 和 Server Params。</p>
<p><strong>3.客户端回应</strong></p>
<p>客户端收到服务器回应以后，开始走证书链逐级验证，确认证书的真实性，如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信：</p>
<p>![image-20200827102309800](/Users/chenyu/Library/Application Support/typora-user-images/image-20200827102309800.png)</p>
<p>如果证书真实有效，再用证书公钥验证签名，就确认了服务器的身份。</p>
<p>然后，向服务器发送下面三项信息：</p>
<ul>
<li>一个随机数。该随机数用服务器公钥加密，防止被窃听</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送（Change Cipher Spec）</li>
<li>客户端握手结束通知（Finished），表示客户端的握手阶段已经结束。这一项是把之前所有发送的数据做个摘要（hash值），再加密一下，供服务器校验</li>
</ul>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>为什么一定要用三个随机数，来生成”会话密钥”？</p>
<p><strong>4.服务器的最后回应</strong></p>
<p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。</p>
<p>然后，向客户端最后发送下面信息：</p>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送（Change Cipher Spec）</li>
<li>客户端握手结束通知（Finished），表示客户端的握手阶段已经结束。这一项是把之前所有发送的数据做个摘要（hash值），再加密一下，供服务器校验</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
